// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Subsystems/Shooter.h"
#include "Robot.h"
#include <frc/SmartDashboard/SmartDashboard.h>
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

//Shooter PID values
const double shooter_P = 0.08;//0.08
const double shooter_I = 0.0008;//0.0008
const double shooter_D = 0.0008;//0.0008
const double shooter_F = 0.008;

const double shooter_SpinUp_P = 0.1;
const double shooter_SpinUp_I = 0.0;
const double shooter_SpinUp_D = 0.0;
const double shooter_SpinUp_F = 0.015;//0.015

const double shooter_Hold_P = 0.1;
const double shooter_Hold_I = 0.0;
const double shooter_Hold_D = 0.0;
const double shooter_Hold_F = 0.015;

const double kMaxSpeed = 6500; //RPM

//Hood Constants
const double hood_P = 3; //0.325
const double hood_I = 0;
const double hood_D = 0;
const double hood_F = 0.0; //0.05

const double hoodLowPos = 0;
const double hoodMedPos = 0;
const double hoodHighPos = 0;

//acceptable hood error from target position
const double acceptableError = 100; //change later
const double acceptableVelError = 500;


Shooter::Shooter() : frc::Subsystem("Shooter") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
shooterMotor1.reset(new WPI_TalonSRX(1));


shooterMotor2.reset(new WPI_VictorSPX(2));


hoodMotor.reset(new WPI_TalonSRX(16));


shooterMotor3.reset(new WPI_VictorSPX(3));


shooterMotor4.reset(new WPI_VictorSPX(4));



    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    // Slavery of the motors
    shooterMotor2->Follow(*shooterMotor1);
    shooterMotor3->Follow(*shooterMotor1);
    shooterMotor4->Follow(*shooterMotor1);
    // setting PID values of master
    
    //Shooter Setup
    shooterMotor1->ConfigSelectedFeedbackSensor(FeedbackDevice::CTRE_MagEncoder_Relative,0);
    shooterMotor1->SetSelectedSensorPosition(0);
    shooterMotor1->SetSensorPhase(true);
    shooterMotor1->ConfigPeakOutputForward(1);
	shooterMotor1->ConfigPeakOutputReverse(-1);
    //shooterMotor1->ConfigVelocityMeasurementPeriod(VelocityMeasPeriod::Period_10Ms);
    //shooterMotor1->ConfigVelocityMeasurementWindow(32);
    shooterMotor1->EnableVoltageCompensation(true);
    shooterMotor1->ConfigVoltageCompSaturation(12);
    shooterMotor1->ConfigAllowableClosedloopError(0,0);

    //shooterMotor1->SetStatusFramePeriod(StatusFrame::Status_1_General_, 2);
    //shooterMotor1->SetStatusFramePeriod(StatusFrame::Status_4_AinTempVbat_, 2);

    //shooterMotor1->SelectProfileSlot(0,0);
    //shooterMotor1->Config_kP(0,shooter_P);
    //shooterMotor1->Config_kI(0,shooter_I);
    //shooterMotor1->Config_kD(0,shooter_D);
    //shooterMotor1->Config_kF(0,shooter_F);

    shooterMotor1->SelectProfileSlot(0,0);
    shooterMotor1->Config_kP(0,shooter_SpinUp_P);
    shooterMotor1->Config_kI(0,shooter_SpinUp_I);
    shooterMotor1->Config_kD(0,shooter_SpinUp_D);
    shooterMotor1->Config_kF(0,shooter_SpinUp_F);

    shooterMotor1->SelectProfileSlot(1,0);
    shooterMotor1->Config_kP(1,shooter_Hold_P);
    shooterMotor1->Config_kI(1,shooter_Hold_I);
    shooterMotor1->Config_kD(1,shooter_Hold_D);
    shooterMotor1->Config_kF(1,shooter_Hold_F);

    //Motion Control
    //shooterMotor1->ConfigMotionCruiseVelocity((7500 * 4096) / 600);
    //shooterMotor1->ConfigMotionAcceleration((3000 * 4096) / 600);
    shootState = 0;

    //Hood Setup
    hoodMotor->ConfigSelectedFeedbackSensor(FeedbackDevice::CTRE_MagEncoder_Relative,0);
    hoodMotor->SetSelectedSensorPosition(0);
    //hoodMotor->SetSensorPhase(true);
    hoodMotor->ConfigPeakOutputForward(1);
	hoodMotor->ConfigPeakOutputReverse(-1);
    hoodMotor->EnableVoltageCompensation(true);
    hoodMotor->ConfigVoltageCompSaturation(12);
    hoodMotor->ConfigAllowableClosedloopError(0,0);
    hoodMotor->Config_kP(0,hood_P);
    hoodMotor->Config_kI(0,hood_I);
    hoodMotor->Config_kD(0,hood_D);
    hoodMotor->Config_kF(0,hood_F);

    frc::SmartDashboard::PutNumber("Shooter Set Point",0);
    frc::SmartDashboard::PutNumber("Hood Set Point",0);
}

void Shooter::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void Shooter::Periodic() {
    frc::SmartDashboard::PutNumber("Shooter Speed", getShooterVel());
    frc::SmartDashboard::PutNumber("Shoot State", shootState);
    //frc::SmartDashboard::PutNumber("Ball Counter", ballCounter);
    frc::SmartDashboard::PutNumber("Target Velocity", shootTargetVel);
    frc::SmartDashboard::PutNumber("Velocity Error", getVelError());
    frc::SmartDashboard::PutNumber("Hood Position",readEncoderPos());
    frc::SmartDashboard::PutNumber("Hood Set Point",hoodTargetPos);
}

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


// Put methods for controlling this subsystem
// here. Call these from Commands.

//-----Shooter Control-----
void Shooter::SetShooterSpeed(double rpm, int val) {
    frc::SmartDashboard::PutNumber("Shooter Set Point",rpm);
    shootTargetVel = rpm;
    shooterMotor1->Set(ControlMode::Velocity,(rpm * 4096) / 600);
}

void Shooter::SetShooterVelocity(double rpm) {
    frc::SmartDashboard::PutNumber("Shooter Set Point",rpm);
    shootTargetVel = rpm;
    shooterMotor1->Set(ControlMode::MotionMagic,(rpm * 4096) / 600);
}

void Shooter::SetShooterPower(double pwr){
    shooterMotor1->Set(pwr);
}

void Shooter::stopShooter(){
    shooterMotor1->Disable();
}

double Shooter::getShooterVel(){
    return ((shooterMotor1->GetSelectedSensorVelocity()* 600) / 4096);
}

double Shooter::getVelError(){
    return abs(shootTargetVel - getShooterVel()); 
}

bool Shooter::shoot(double targetRPM, bool isAimed, bool manual){
    switch(shootState) {
        case 0:
            {
            //Pre-calculations
            m_TotalTime = 1; //Amount of time to reach speed
            shooterMotor1->SelectProfileSlot(0,0);
            m_OriginalTime = frc::Timer::GetFPGATimestamp();
            shootState = 1;
            }
            break;
        case 1:
            {
            double currTime = frc::Timer::GetFPGATimestamp() - m_OriginalTime;
            double rpm = targetRPM * currTime / m_TotalTime;
            if(rpm > targetRPM)
                rpm = targetRPM;
            SetShooterSpeed(rpm);
            if (currTime > m_TotalTime){
                shooterMotor1->SelectProfileSlot(1,0);
                SetShooterSpeed(rpm);
                shootState = 2;
                m_Counter = 0;
            }
            }
            break;
        case 2:
            m_Counter++;
            if(m_Counter > 5){
                m_Counter = 0;
                shootState = 3;
            }
            break;
        case 3:
            if(isAimed && !manual) {
                Robot::intakes->spinMag();
            } else if(isAimed && manual && Robot::oi->getDriverGamepad()->GetRawButton(9)) {
                if(Robot::intakes->index(true)) {
                    Robot::intakes->shiftCells(true);
                }
            }
            m_Counter++;
            if(m_Counter > 150 && !manual){
                shootState = 4;
                m_Counter = 0;
            }
            break;
        case 4:
            if(!Robot::intakes->getMagHighSensor())
                m_Counter++;
            else
                m_Counter = 0;
            if(m_Counter > 20){
                disableHood();
                return true;
            }
            break;
    }
    return false;
    
}

//-----Hood control-----
double Shooter::readEncoderPos(){
    return hoodMotor->GetSelectedSensorPosition();
}

double Shooter::findHoodError(){
    return hoodTargetPos - readEncoderPos();
}

void Shooter::disableHood(){
    hoodMotor->Disable();
}

bool Shooter::goToHoodPos(double target){
    hoodMotor->Set(ControlMode::Position,target);
    hoodTargetPos = target;
    

    if(findHoodError() <= acceptableError)
        count++;
    else 
        count = 0;

    if(count >= 10){
        count = 0;
        return true;
    }
    return false;
}

/*
bool Shooter::shoot(double distance, double angle){
    switch(shootState) {
        case 0:
            if (getVelError() >= acceptableVelError){
                SetShooterSpeed(getTargetShootVel());
            }
            else {
                shootState++;
            }
        break;
        case 1:
            if (Robot::intakes->index(true)){
                Robot::intakes->clearCellPosition(4);
                Robot::intakes->shiftCells(false);
                shootState++;
                if (Robot::intakes->countCells() == 0){
                    shootState = 0;
                    shootDelay = 0;
                    return true;
                }
            }
        break;
        case 2:
            shootDelay++;
            if (shootDelay >= 20){
                shootDelay = 0;
                shootState--;
            }
        break;
    }
    return false;
    
}
*/
