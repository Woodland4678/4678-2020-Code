// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Subsystems/Intakes.h"
#include <frc/SmartDashboard/SmartDashboard.h>

const double INTAKESPEED = 0.70;
const double MAGSPEED = 1;
const double INDEXENCODER = 10;
const double INDEXERROR = 0.5;

const double MAG_P = 0.05;
const double MAG_I = 0;
const double MAG_D = 0;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

Intakes::Intakes() : frc::Subsystem("Intakes") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
middleRoller.reset(new rev::CANSparkMax(6, rev::CANSparkMax::MotorType::kBrushless));


magazine.reset(new rev::CANSparkMax(8, rev::CANSparkMax::MotorType::kBrushless));


magazineSensor1.reset(new frc::DigitalInput(0));
AddChild("magazineSensor1", magazineSensor1);

magazineSensor2.reset(new frc::DigitalInput(1));
AddChild("magazineSensor2", magazineSensor2);

intakeSolenoid.reset(new frc::Solenoid(0, 1));
AddChild("intakeSolenoid", intakeSolenoid);

leftRoller.reset(new rev::CANSparkMax(4, rev::CANSparkMax::MotorType::kBrushless));


rightRoller.reset(new rev::CANSparkMax(7, rev::CANSparkMax::MotorType::kBrushless));


leftSensor.reset(new frc::DigitalInput(2));
AddChild("leftSensor", leftSensor);

rightSensor.reset(new frc::DigitalInput(3));
AddChild("rightSensor", rightSensor);


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    //Initialize Magazine Motor
    magazine->GetPIDController().SetP(MAG_P,0);
    magazine->GetPIDController().SetI(MAG_I,0);
    magazine->GetPIDController().SetD(MAG_D,0);
}

void Intakes::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void Intakes::Periodic() {
    //When deployed start looking for power cells
    if(m_deployed){
        if(index())
            m_powerCellCount++;
        if(m_powerCellCount == 5)
            retractIntakes();
    }
}

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


// Put methods for controlling this subsystem
// here. Call these from Commands.

//----------------------------------------Intake State Control-------------------------------------
void Intakes::deployIntakes(){
    m_deployed = true;
    setIntakeSpeed(INTAKESPEED,INTAKESPEED,INTAKESPEED);
    intakeSolenoid->Set(true);
}

void Intakes::retractIntakes(){
    m_deployed = false;
    stopIntakes();
    intakeSolenoid->Set(false);
}

bool Intakes::isDeployed(){
    return m_deployed;
}

//----------------------------------------Intake Speed Control-------------------------------------
void Intakes::stopLeft(){
    leftRoller->Disable();
}

void Intakes::stopRight(){
    rightRoller->Disable();
}
void Intakes::stopMiddle(){
    middleRoller->Disable();
}

void Intakes::setLeft(double speed){
    leftRoller->Set(-speed);
}

void Intakes::setRight(double speed){
    rightRoller->Set(speed);
}
void Intakes::setMiddle(double speed) {
    middleRoller->Set(speed);
}

void Intakes::setIntakeSpeed(double rightSpeed, double leftSpeed, double middleSpeed) {
    setRight(rightSpeed);
    setLeft(leftSpeed);
    setMiddle(middleSpeed);
}

void Intakes::stopIntakes(){
    stopLeft();
    stopRight();
    stopMiddle();
}

void Intakes::spitoutIntakes(){
    setRight(-INTAKESPEED);
    setLeft(-INTAKESPEED);
    setMiddle(-INTAKESPEED);
}

//------------------------------------------Magazine Control---------------------------------------
void Intakes::spinMag(){
    magazine->Set(MAGSPEED);
}

void Intakes::stopMag(){
    magazine->Disable();
}

void Intakes::spitoutMag(){
    magazine->Set(-MAGSPEED);
}

void Intakes::setMagazinePosition(double encoder) {
    magazine->GetPIDController().SetReference(encoder,rev::ControlType::kPosition,0);
}

double Intakes::getMagazinePosition(){
    return magazine->GetEncoder().GetPosition();
}

void Intakes::incrementCellCount(){
    m_powerCellCount++;
}

void Intakes::decrementCellCount(){
    m_powerCellCount--;
}

int Intakes::getCellCount(){
    return m_powerCellCount;
}

//
bool Intakes::index(){
    if(m_idxState > 0)
        m_idxcnt++;
    switch(m_idxState){
        case INDEXWAITING:
            if(!magazineSensor2->Get()){
                m_idxState = INDEXCELL;
                setMagazinePosition(INDEXENCODER);
            }
            break;
        case INDEXCELL:
            {
            double err = abs(INDEXENCODER - getMagazinePosition());
            if(err < INDEXERROR)
                m_idxState = INDEXCOMPLETE;
            }
            break;
        case INDEXCOMPLETE:
            stopMag();
            magazine->GetEncoder().SetPosition(0);
            m_idxState = INDEXWAITING;
            return true;
            break;
    }
    return false;
}


//--Old Code--
/*bool Intakes::index(){
    if(m_idxState > 0)
        m_idxcnt++;
    switch(m_idxState){
        case 0:
            if(!magazineSensor2->Get())
                m_idxState = 1;
            break;
        case 1:
            magazine->Set(-0.4);
            m_prevDetect = magazineSensor2->Get();
            m_idxcnt = 0;
            if(!m_prevDetect)
                m_idxState = 1;
            else
                m_idxState = 2;
            break;
        case 2:
            //Wait until magazineSensor2 finds a gap
            m_prevDetect = magazineSensor2->Get();
            if((m_prevDetect)){
                m_idxState = 3;
                m_idxcnt = 0;
            }
            break;
        case 3:
            m_prevDetect = magazineSensor2->Get();
            if((!m_prevDetect)){
                //We have the ball in the right place, stop the motor
                magazine->Set(0);
                m_idxState = 0;
                return true;
            }
            break;
    }
    return false;
}*/