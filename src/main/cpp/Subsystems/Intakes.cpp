// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Subsystems/Intakes.h"
#include <frc/SmartDashboard/SmartDashboard.h>

const double INTAKESPEED = 0.90;
const double MAGSPEED = -1;
const double INDEXENCODER = -20;
const double INDEXERROR = 0.5;
const int REVMIDDLECNT = 3;
const double REVMIDDLESPEED = 0;

const double MAG_P = 1;
const double MAG_I = 0;
const double MAG_D = 0;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

Intakes::Intakes() : frc::Subsystem("Intakes") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
middleRoller.reset(new rev::CANSparkMax(11, rev::CANSparkMax::MotorType::kBrushless));


magazine.reset(new rev::CANSparkMax(13, rev::CANSparkMax::MotorType::kBrushless));


magazineSensorLow.reset(new frc::DigitalInput(0));
AddChild("magazineSensorLow", magazineSensorLow);

magazineSensorHigh.reset(new frc::DigitalInput(1));
AddChild("magazineSensorHigh", magazineSensorHigh);

intakeSolenoid.reset(new frc::Solenoid(0, 1));
AddChild("intakeSolenoid", intakeSolenoid);

leftRoller.reset(new rev::CANSparkMax(7, rev::CANSparkMax::MotorType::kBrushless));


rightRoller.reset(new rev::CANSparkMax(8, rev::CANSparkMax::MotorType::kBrushless));



    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    cells[0] = true;
    cells[1] = true;
    cells[2] = true;
    cells[3] = false;
    cells[4] = false;

    //Initialize Magazine Motor
    magazine->GetPIDController().SetP(MAG_P,0);
    magazine->GetPIDController().SetI(MAG_I,0);
    magazine->GetPIDController().SetD(MAG_D,0);

    magazine->GetPIDController().SetOutputRange(-1, 1);

    //Current Limiting
    //magazine->SetSmartCurrentLimit(20);

    magazine->GetEncoder().SetPosition(0);
}

void Intakes::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void Intakes::Periodic() {
    frc::SmartDashboard::PutNumber("Mag Amps", magazine->GetOutputCurrent());
    frc::SmartDashboard::PutNumber("Power Cells", countCells());
    frc::SmartDashboard::PutNumber("Intake Encoder", getMagazinePosition());
    frc::SmartDashboard::PutBoolean("Intake Deployed", m_deployed);
    frc::SmartDashboard::PutBoolean("Cell 1 State", cells[0]);
    frc::SmartDashboard::PutBoolean("Cell 2 State", cells[1]);
    frc::SmartDashboard::PutBoolean("Cell 3 State", cells[2]);
    frc::SmartDashboard::PutBoolean("Cell 4 State", cells[3]);
    frc::SmartDashboard::PutBoolean("Cell 5 State", cells[4]);
    frc::SmartDashboard::PutNumber("Index State",m_idxState);
    frc::SmartDashboard::PutBoolean("Index Sensor",!magazineSensorLow->Get());


    //When deployed start looking for power cells
    if(m_deployed){
        if(index())
            shiftCells(true);
        if(magazineSensorHigh->Get() == false){
            stopMag();
            resetMagazinePosition();
            retractIntakes();
        }
    }
}

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


// Put methods for controlling this subsystem
// here. Call these from Commands.

//----------------------------------------Intake State Control-------------------------------------
void Intakes::deployIntakes(){
    m_deployed = true;
    setIntakeSpeed(INTAKESPEED,INTAKESPEED,INTAKESPEED);
    intakeSolenoid->Set(true);
}

void Intakes::retractIntakes(){
    m_deployed = false;
    stopIntakes();
    intakeSolenoid->Set(false);
}

bool Intakes::isDeployed(){
    return m_deployed;
}

//----------------------------------------Intake Speed Control-------------------------------------
void Intakes::stopLeft(){
    leftRoller->Disable();
}

void Intakes::stopRight(){
    rightRoller->Disable();
}
void Intakes::stopMiddle(){
    middleRoller->Disable();
}

void Intakes::setLeft(double speed){
    leftRoller->Set(-speed);
}

void Intakes::setRight(double speed){
    rightRoller->Set(speed);
}
void Intakes::setMiddle(double speed) {
    middleRoller->Set(speed);
}

void Intakes::setIntakeSpeed(double rightSpeed, double leftSpeed, double middleSpeed) {
    setRight(rightSpeed);
    setLeft(leftSpeed);
    setMiddle(middleSpeed);
}

void Intakes::stopIntakes(){
    stopLeft();
    stopRight();
    stopMiddle();
}

void Intakes::spitoutIntakes(){
    setRight(-INTAKESPEED);
    setLeft(-INTAKESPEED);
    setMiddle(-INTAKESPEED);
}

void Intakes::clearMagEncoder(){
    magazine->GetEncoder().SetPosition(0);
}

//------------------------------------------Magazine Control---------------------------------------
void Intakes::spinMag(){
    magazine->Set(MAGSPEED);
}

void Intakes::stopMag(){
    magazine->Disable();
}

void Intakes::spitoutMag(){
    magazine->Set(-MAGSPEED);
}

void Intakes::setMagazinePosition(double encoder) {
    magazine->GetPIDController().SetReference(encoder,rev::ControlType::kPosition,0);
}

double Intakes::getMagazinePosition(){
    return magazine->GetEncoder().GetPosition();
}

void Intakes::resetMagazinePosition(){
    m_idxState = 0;
    magazine->GetEncoder().SetPosition(0);
}

void Intakes::setCellPosition(int position){
    cells[position] = true;
}

void Intakes::clearCellPosition(int position){
    cells[position] = false;
}

int Intakes::countCells(){
    cellCounter = 0;
    for (int i = 0; i < 5; i++){
        if (cells[i] == true){
            cellCounter++;
        }
    }
    return cellCounter;
}

bool Intakes::shiftCells(bool firstCell){
    if (cells[4]){
        return false;
    }
    for (int i = 4; i >= 1; i--){
        cells[i] = cells[i-1];
    }
    cells[0] = firstCell;
    return true;
}

bool Intakes::getMagHighSensor(){
    return magazineSensorHigh->Get() ^ 1;
}

bool Intakes::index(bool c1Override){
    if(m_idxState > 0)
        m_idxcnt++;
    switch(m_idxState){
        case INDEXWAITING:
            if((!magazineSensorLow->Get())||(c1Override)){
                m_idxState = INDEXCELL;
                m_idxcnt = 0;
                setMagazinePosition(INDEXENCODER);
                //setMiddle(REVMIDDLESPEED);
            }
            break;
        case INDEXCELL:
            {
            //Move the middle roller backwards for a short peroid of time to avoid two cells
            //  colliding in the indexer.
            //if(m_idxcnt == REVMIDDLECNT)
            //    setMiddle(INTAKESPEED);
            //Check for when the shooter gets up to speed
            double err = abs(INDEXENCODER - getMagazinePosition());
            if(err < INDEXERROR)
                m_idxState = INDEXCOMPLETE;
            }
            if(m_idxcnt > 50){
                magazine->GetEncoder().SetPosition(0);
                m_idxState = INDEXWAITING;
            }
            break;
        case INDEXCOMPLETE:
            stopMag();
            magazine->GetEncoder().SetPosition(0);
            m_idxState = INDEXWAITING;
            return true;
            break;
    }
    return false;
}


//--Old Code--
/*bool Intakes::index(){
    if(m_idxState > 0)
        m_idxcnt++;
    switch(m_idxState){
        case 0:
            if(!magazineSensorLow->Get())
                m_idxState = 1;
            break;
        case 1:
            magazine->Set(-0.4);
            m_prevDetect = magazineSensorLow->Get();
            m_idxcnt = 0;
            if(!m_prevDetect)
                m_idxState = 1;
            else
                m_idxState = 2;
            break;
        case 2:
            //Wait until magazineSensorLow finds a gap
            m_prevDetect = magazineSensorLow->Get();
            if((m_prevDetect)){
                m_idxState = 3;
                m_idxcnt = 0;
            }
            break;
        case 3:
            m_prevDetect = magazineSensorLow->Get();
            if((!m_prevDetect)){
                //We have the ball in the right place, stop the motor
                magazine->Set(0);
                m_idxState = 0;
                return true;
            }
            break;
    }
    return false;
}*/
