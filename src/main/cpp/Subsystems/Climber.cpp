// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Subsystems/Climber.h"
#include "Robot.h"
#include <frc/SmartDashboard/SmartDashboard.h>
const double CLIMB_P = 1;
const double CLIMB_I = 0;
const double CLIMB_D = 0;
const double kExtendValue = 17;
const double kExtendTime = 2;
const double kMoveSpeedMod = 0.25;
const double kMinValue = 9;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

Climber::Climber() : frc::Subsystem("Climber") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
climberMotor.reset(new rev::CANSparkMax(14, rev::CANSparkMax::MotorType::kBrushless));


rachetServo.reset(new frc::Servo(0));
AddChild("rachetServo", rachetServo);

climberSolenoid.reset(new frc::Solenoid(0, 0));
AddChild("climberSolenoid", climberSolenoid);

shimmyMotor.reset(new WPI_VictorSPX(17));



    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS


    rachetDetection.reset(new frc::DigitalInput(5));
    AddChild("rachetDetection", rachetDetection);

climberMotor->GetPIDController().SetP(CLIMB_P,0);
climberMotor->GetPIDController().SetI(CLIMB_I,0);
climberMotor->GetPIDController().SetD(CLIMB_D,0);
climberMotor->GetEncoder().SetPosition(0);
climberMotor->SetSmartCurrentLimit(80);//30
frc::SmartDashboard::PutNumber("CMove",0);
frc::SmartDashboard::PutNumber("CMoveState",0);
frc::SmartDashboard::PutNumber("CMod", 0);
}

void Climber::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void Climber::Periodic() {
    // Put code here to be run every loop
    frc::SmartDashboard::PutNumber("Climber Encoder", climberMotor->GetEncoder().GetPosition());
    frc::SmartDashboard::PutNumber("Climber Extended", isExtended);
    double shim = Robot::oi->getOperatorGamepad()->GetX();
    double clim = -Robot::oi->getOperatorGamepad()->GetRawAxis(3);
    if(isExtended){
        if(!isClimbing){
            //move the climber or shimmy
            setShimmyMotor(shim);
            //The maximum value is stored in kExtendValue
            //  If I use the joystick as a speed control, the higher the value the faster the climber moves
            //      There will have to be a min and max
            //      Take the current position and add the joystick value, 
            //      can add a multiplyer to slow it down as 1 encoder value will be rather quick
            if((clim > -0.075)&&(clim < 0.075))
                clim = 0;
            double climPos = climberMotor->GetEncoder().GetPosition() + (clim * kMoveSpeedMod);
            if(climPos > 18)
                climPos = 18;
            if(climPos < kMinValue)
                climPos = kMinValue;
            frc::SmartDashboard::PutNumber("CMod", climPos);
            setClimberPosition(climPos);
        }
    }
    else{
        if(fabs(clim) > 0.1){
            //Check if the climber position is extended
            if(climberMotor->GetEncoder().GetPosition() > 10)
                isExtended = true;
        }
    }
}

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

bool Climber::lock() {
    rachetServo->Set(1);
    if(rachetDetection->Get())
        return true;
    return false;
}
bool Climber::unlock(){
    switch (unlockCase) {
        case 0:
            rachetServo->Set(0.7);
            unlockCase = 1;
        break;
        case 1:
            cnt++;
            if (cnt > 20) {
                unlockCase = 2;
            }
        break;
        case 2:
            //setClimberPosition(climberMotor->GetEncoder().GetPosition() - 1);
            unlockCase = 3;
        break;
        case 3:
            if(!rachetDetection->Get()){
                unlockCase = 0;
                return true;
            }
        break;
    }
    //rachetServo->Set(0);
    return false;
}

bool Climber::extend(){
    frc::SmartDashboard::PutNumber("CMoveState",extendCase);
    switch(extendCase){
        case 0://Init, stop once unlocked
            shiftToExtendMode();
            if(unlock()){
                extendStart = frc::Timer::GetFPGATimestamp();
                extendCase = 1;
            }
            break;
        case 1://Begin extension
            {
            double currTime = frc::Timer::GetFPGATimestamp() - extendStart;
            double pos = kExtendValue * currTime / kExtendTime;
            if(pos > kExtendValue)
                pos = kExtendValue;
            frc::SmartDashboard::PutNumber("CMove",pos);
            setClimberPosition(pos);
            if (currTime > kExtendTime){
                setClimberPosition(kExtendValue);
                extendCase = 2;
            }
            }
            break;
        case 2://End, lock and the like
            lock();
            extendCase = 0;
            isExtended = true;
            isClimbing = false;
            return true;
            break;
    }
    return false;
}

bool Climber::retract(){
    frc::SmartDashboard::PutNumber("CPMoveState",retractCase);
    switch(retractCase) {
        case 0: //Init
            shiftToWinchMode();
            isClimbing = true;
            pullupPos = climberMotor->GetEncoder().GetPosition();
            retractCnt = 0;
            retractCase = 1;
            break;
        case 1:
            retractCnt++;
            if(retractCnt > 10){
                retractCase = 2;
                retractCnt = 0;
                setClimberPosition(pullupPos+1);
            }
            break;
        case 2:
            //Move slightly to get the gears to catch
            retractCnt++;
            if(retractCnt > 5){
                retractCase = 3;
                retractCnt = 0;
                setClimberPosition(pullupPos-1);
            }
            break;
        case 3:
            retractCnt++;
            if(retractCnt > 5){
                retractCase = 4;
                retractCnt = 0;
            }
            break;
        case 4:
            setClimberPosition(pullupPos + 64);
            retractCase = 5;
            retractCnt = 0;
            break;
        case 5:
            retractCnt++;
            if(retractCnt >= 200){
                retractCase = 0;
                retractCnt = 0;
                return true;
            }
            break;
    }
    return false;
}

//Positive is up
//22 is straight up
void Climber::setClimberPosition(double position) {
    climberMotor->GetPIDController().SetReference(position,rev::ControlType::kPosition,0);
}
void Climber::setClimberPower(double power) {
    climberMotor->Set(power);
}
void Climber::setShimmyMotor(double power) {
    shimmyMotor->Set(power);
}
void Climber::shiftToExtendMode() {
    climberSolenoid->Set(false);
}
void Climber::shiftToWinchMode() {
    climberSolenoid->Set(true);
    //climberMotor->Disable();
}
// Put methods for controlling this subsystem
// here. Call these from Commands.

