// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Commands/Autonomous/AutoTenBall.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

AutoTenBall::AutoTenBall(): frc::Command() {
    // Use Requires() here to declare subsystem dependencies
    // eg. Requires(Robot::chassis.get());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
}// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

// Called just before this Command runs the first time
void AutoTenBall::Initialize() {
    path1 = new PathFinder(0.02,3,2,1,0.545);  // cycle time (s), max velocity (m/s), max acceleration (m/s^2), max jerk (m/s^3), distance between wheels (m)
    path1->createNewPath();
    path1->addWayPoint(0, 0, 0);  // X is in front of robot, -X is behind, -Y is left, +Y is right
    path1->addWayPoint(1.75, 0, 0); //2.44, 0, 0 - meters
    path1->addWayPoint(2.35, 0.5, 45); //2.44, 0, 0 - meters
    path1->makePath();

    path2 = new PathFinder(0.02,3,2,1,0.545);
    path2->createNewPath();
    path2->addWayPoint(2.35, 0.5, 45);
    path2->addWayPoint(0,0,0);
    path2->makePath();

    path3 = new PathFinder(0.02,3,2,1,0.545);
    path3->createNewPath();
    path3->addWayPoint(0, 0, 0);
    path3->addWayPoint(-2.35,1.7,0);
    path3->addWayPoint(-6.57, 1.7,0);
    path3->makePath();

    path4 = new PathFinder(0.02,3,2,1,0.545);
    path4->createNewPath();
    path4->addWayPoint(-6.57, 1.7, 0);
    path4->addWayPoint(-4,1.7,0);
    path4->addWayPoint(0,0,0);
    path4->makePath();

    cnt = 0;
    Robot::drivetrain->resetGyro();
    path1->startTraverse(frc::Timer::GetFPGATimestamp());
}

// Called repeatedly when this Command is scheduled to run
void AutoTenBall::Execute() {
    switch(autoStep) {
        case grabTwoBalls:
            Robot::shooter->SetShooterSpeed(2500); //will need to adjust shooter speed in the future
            Robot::shooter->goToHoodPos(0); //will need to adjust this value
            Robot::intakes->deployIntakes();
            if (path1->traverse(frc::Timer::GetFPGATimestamp(),&rVel,&lVel,Robot::drivetrain->getGyroReading())) {   // cnt = how far down the path are you, right velocity (m/s), left velocity (m/s)
                autoStep = delay;
                nextAutoStep = returnToShootFirstVolley;
                delayCount = 50;
                path2->startTraverse(frc::Timer::GetFPGATimestamp());
                rVel = 0;
                lVel = 0;
                cnt = 0;
            }

            Robot::drivetrain->setRightVelocity(rVel);
            Robot::drivetrain->setLeftVelocity(lVel);
            cnt++;
        break;
        case returnToShootFirstVolley:
            if (path2->traverse(frc::Timer::GetFPGATimestamp(),&rVel,&lVel,Robot::drivetrain->getGyroReading())) {   // cnt = how far down the path are you, right velocity (m/s), left velocity (m/s)
                autoStep = shoot;
                rVel = 0;
                lVel = 0;
                cnt = 0;
            }
            Robot::drivetrain->setRightVelocity(rVel);
            Robot::drivetrain->setLeftVelocity(lVel);
            cnt++;
        break;
        case shoot:
            Robot::intakes->spinMag();
            // if (Robot::intakes->countCells() == 0) {
            //     autoStep = runTrench;
            //     path3->startTraverse(frc::Timer::GetFPGATimestamp());
            //     Robot::shooter->goToHoodPos(0); //lower hood so we go through trench
            // }
        break;
        case runTrench:
            Robot::intakes->deployIntakes();
            if (path3->traverse(frc::Timer::GetFPGATimestamp(),&rVel,&lVel,Robot::drivetrain->getGyroReading())) {   // cnt = how far down the path are you, right velocity (m/s), left velocity (m/s)
                autoStep = returnToShootSecondVolley;
                path4->startTraverse(frc::Timer::GetFPGATimestamp());
                rVel = 0;
                lVel = 0;
                cnt = 0;
            }
            Robot::drivetrain->setRightVelocity(rVel);
            Robot::drivetrain->setLeftVelocity(lVel);
            cnt++;
        break;
        case returnToShootSecondVolley:
            if (path4->traverse(frc::Timer::GetFPGATimestamp(),&rVel,&lVel,Robot::drivetrain->getGyroReading())) {   // cnt = how far down the path are you, right velocity (m/s), left velocity (m/s)
                autoStep = finalAutoAim;
                rVel = 0;
                lVel = 0;
                cnt = 0;
            }
            Robot::drivetrain->setRightVelocity(rVel);
            Robot::drivetrain->setLeftVelocity(lVel);
            cnt++;
        break;
        case finalAutoAim:
            if (Robot::drivetrain->autoAim(0) < 1) {
                autoStep = finalShoot;
            }
        break;
        case finalShoot:
            Robot::intakes->spinMag();
        break;
        case delay:
            if (cnt >= delayCount) {
                autoStep = nextAutoStep;
                cnt = 0;
            }
            cnt++;
        break;
    }
}

// Make this return true when this Command no longer needs to run execute()
bool AutoTenBall::IsFinished() {
    return false;
}

// Called once after isFinished returns true
void AutoTenBall::End() {

}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void AutoTenBall::Interrupted() {

}
